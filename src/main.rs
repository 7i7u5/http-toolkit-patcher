//TODO: auto detect version and see if we can patch...
use std::collections::HashMap;
use std::sync::{OnceLock};
use std::path::{ Path, PathBuf };
use std::env;
use std::fs;
use asar::{ AsarReader, AsarWriter };
use walkdir::WalkDir;
use sha2::{Sha256, Digest};

struct Patch {
	original: Vec<u8>,
	replacement: Vec<u8>,
}

#[derive(Clone)]
struct PatchPaths {
	base_paths: Vec<String>,
	binary_path: &'static str,
	asar_path: &'static str
}

static PATCHES: OnceLock<HashMap<String, Vec<Patch>>> = OnceLock::new();
static PATCH_PATHS: OnceLock<HashMap<String, PatchPaths>> = OnceLock::new();

fn init_patch_paths() -> &'static HashMap<String, PatchPaths> {
	PATCH_PATHS.get_or_init(|| {
		let mut m = HashMap::new();
		m.insert("windows".to_string(), PatchPaths {
			base_paths: vec![
				"C:/Program Files/HTTP Toolkit".to_string(),
				format!("C:/Users/{}/AppData/Local/Programs/HTTP Toolkit", whoami::username())
			],
			binary_path: "HTTP Toolkit.exe",
			asar_path: "resources/app.asar"
		});

		// m.insert("unix".to_string(), PatchPaths {
		// 	base_paths: vec![
		// 		"/opt/HTTP Toolkit".to_string(),
		// 	],
		// 	binary_path: "httptoolkit",
		// 	asar_path: "resources/app.asar"
		// });

		// m.insert("macos".to_string(), vec![
		//TODO: patch for non windows
		// ]);

		return m;
	})
}

fn init_patches() -> &'static HashMap<String, Vec<Patch>> {
	PATCHES.get_or_init(|| {
		let mut m = HashMap::new();
		m.insert("build/index.js".to_string(), vec![
			Patch {
				original: vec![
					0x20, 0x20, 0x20, 0x20, 0x7d, 0x29, 0x3b, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66, 0x20, 0x28, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x41, 0x75, 0x74, 0x6f, 0x48, 0x69, 0x64, 0x65, 0x4d, 0x65, 0x6e, 0x75, 0x28, 0x29, 0x29, 0x20, 0x7b				],
				replacement: vec![
					0x20, 0x20, 0x20, 0x20, 0x7d, 0x29, 0x3b, 0x0d, 0x0a, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x20, 0x70, 0x61, 0x74, 0x63, 0x68, 0x5f, 0x61, 0x6c, 0x65, 0x72, 0x74, 0x3d, 0x28, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x2c, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x3d, 0x33, 0x65, 0x33, 0x29, 0x3d, 0x3e, 0x7b, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x2e, 0x77, 0x65, 0x62, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x4a, 0x61, 0x76, 0x61, 0x53, 0x63, 0x72, 0x69, 0x70, 0x74, 0x28, 0x60, 0x6c, 0x65, 0x74, 0x20, 0x64, 0x69, 0x76, 0x20, 0x3d, 0x20, 0x64, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x45, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x28, 0x22, 0x64, 0x69, 0x76, 0x22, 0x29, 0x3b, 0x5c, 0x6e, 0x6c, 0x65, 0x74, 0x20, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x3d, 0x20, 0x24, 0x7b, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x7d, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x20, 0x3d, 0x20, 0x22, 0x34, 0x30, 0x70, 0x78, 0x22, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x62, 0x61, 0x63, 0x6b, 0x67, 0x72, 0x6f, 0x75, 0x6e, 0x64, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x20, 0x3d, 0x20, 0x22, 0x72, 0x67, 0x62, 0x28, 0x35, 0x30, 0x2c, 0x20, 0x35, 0x32, 0x2c, 0x20, 0x35, 0x39, 0x29, 0x22, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x3d, 0x20, 0x22, 0x66, 0x69, 0x78, 0x65, 0x64, 0x22, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x62, 0x6f, 0x74, 0x74, 0x6f, 0x6d, 0x20, 0x3d, 0x20, 0x22, 0x2d, 0x35, 0x30, 0x70, 0x78, 0x22, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x3d, 0x20, 0x22, 0x32, 0x30, 0x70, 0x78, 0x22, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x6f, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x20, 0x3d, 0x20, 0x30, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x62, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x52, 0x61, 0x64, 0x69, 0x75, 0x73, 0x20, 0x3d, 0x20, 0x22, 0x35, 0x70, 0x78, 0x22, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x64, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x20, 0x3d, 0x20, 0x22, 0x66, 0x6c, 0x65, 0x78, 0x22, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x61, 0x6c, 0x69, 0x67, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x20, 0x3d, 0x20, 0x22, 0x63, 0x65, 0x6e, 0x74, 0x65, 0x72, 0x22, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x6a, 0x75, 0x73, 0x74, 0x69, 0x66, 0x79, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x20, 0x3d, 0x20, 0x22, 0x63, 0x65, 0x6e, 0x74, 0x65, 0x72, 0x22, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x63, 0x75, 0x72, 0x73, 0x6f, 0x72, 0x20, 0x3d, 0x20, 0x22, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x22, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x70, 0x61, 0x64, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x3d, 0x20, 0x22, 0x30, 0x20, 0x31, 0x35, 0x70, 0x78, 0x22, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x62, 0x6f, 0x78, 0x53, 0x68, 0x61, 0x64, 0x6f, 0x77, 0x20, 0x3d, 0x20, 0x22, 0x32, 0x70, 0x78, 0x20, 0x33, 0x70, 0x78, 0x20, 0x36, 0x70, 0x78, 0x20, 0x72, 0x67, 0x62, 0x61, 0x28, 0x30, 0x2c, 0x20, 0x30, 0x2c, 0x20, 0x30, 0x2c, 0x20, 0x30, 0x2e, 0x35, 0x29, 0x22, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x20, 0x3d, 0x20, 0x22, 0x72, 0x67, 0x62, 0x28, 0x32, 0x31, 0x38, 0x2c, 0x20, 0x32, 0x31, 0x39, 0x2c, 0x20, 0x32, 0x32, 0x33, 0x29, 0x22, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x66, 0x6f, 0x6e, 0x74, 0x46, 0x61, 0x6d, 0x69, 0x6c, 0x79, 0x20, 0x3d, 0x20, 0x27, 0x22, 0x44, 0x4d, 0x20, 0x53, 0x61, 0x6e, 0x73, 0x22, 0x2c, 0x20, 0x41, 0x72, 0x69, 0x61, 0x6c, 0x2c, 0x20, 0x73, 0x61, 0x6e, 0x73, 0x2d, 0x73, 0x65, 0x72, 0x69, 0x66, 0x27, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x66, 0x6f, 0x6e, 0x74, 0x53, 0x69, 0x7a, 0x65, 0x20, 0x3d, 0x20, 0x22, 0x31, 0x37, 0x70, 0x78, 0x22, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x74, 0x65, 0x78, 0x74, 0x44, 0x65, 0x63, 0x6f, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x3d, 0x20, 0x22, 0x6e, 0x6f, 0x6e, 0x65, 0x22, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x3d, 0x20, 0x22, 0x61, 0x6c, 0x6c, 0x20, 0x30, 0x2e, 0x35, 0x73, 0x20, 0x65, 0x61, 0x73, 0x65, 0x22, 0x3b, 0x5c, 0x6e, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x74, 0x65, 0x78, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x20, 0x3d, 0x20, 0x22, 0x24, 0x7b, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x7d, 0x22, 0x3b, 0x5c, 0x6e, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x6f, 0x6e, 0x63, 0x6c, 0x69, 0x63, 0x6b, 0x20, 0x3d, 0x20, 0x28, 0x29, 0x20, 0x3d, 0x3e, 0x20, 0x7b, 0x5c, 0x6e, 0x20, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x2e, 0x6f, 0x70, 0x65, 0x6e, 0x28, 0x22, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x37, 0x69, 0x37, 0x75, 0x35, 0x2f, 0x68, 0x74, 0x74, 0x70, 0x2d, 0x74, 0x6f, 0x6f, 0x6c, 0x6b, 0x69, 0x74, 0x2d, 0x70, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x22, 0x2c, 0x20, 0x22, 0x5f, 0x62, 0x6c, 0x61, 0x6e, 0x6b, 0x22, 0x29, 0x3b, 0x5c, 0x6e, 0x7d, 0x3b, 0x5c, 0x6e, 0x5c, 0x6e, 0x64, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x62, 0x6f, 0x64, 0x79, 0x2e, 0x61, 0x70, 0x70, 0x65, 0x6e, 0x64, 0x43, 0x68, 0x69, 0x6c, 0x64, 0x28, 0x64, 0x69, 0x76, 0x29, 0x3b, 0x5c, 0x6e, 0x5c, 0x6e, 0x73, 0x65, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x28, 0x28, 0x29, 0x20, 0x3d, 0x3e, 0x20, 0x7b, 0x5c, 0x6e, 0x20, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x62, 0x6f, 0x74, 0x74, 0x6f, 0x6d, 0x20, 0x3d, 0x20, 0x22, 0x31, 0x30, 0x70, 0x78, 0x22, 0x3b, 0x5c, 0x6e, 0x20, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x6f, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x20, 0x3d, 0x20, 0x30, 0x2e, 0x38, 0x3b, 0x5c, 0x6e, 0x7d, 0x2c, 0x20, 0x35, 0x30, 0x29, 0x3b, 0x5c, 0x6e, 0x5c, 0x6e, 0x73, 0x65, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x28, 0x28, 0x29, 0x20, 0x3d, 0x3e, 0x20, 0x7b, 0x5c, 0x6e, 0x20, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x62, 0x6f, 0x74, 0x74, 0x6f, 0x6d, 0x20, 0x3d, 0x20, 0x22, 0x2d, 0x35, 0x30, 0x70, 0x78, 0x22, 0x3b, 0x5c, 0x6e, 0x20, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x6f, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x20, 0x3d, 0x20, 0x30, 0x3b, 0x5c, 0x6e, 0x7d, 0x2c, 0x20, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x2b, 0x20, 0x35, 0x30, 0x30, 0x29, 0x3b, 0x5c, 0x6e, 0x5c, 0x6e, 0x73, 0x65, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x28, 0x28, 0x29, 0x20, 0x3d, 0x3e, 0x20, 0x7b, 0x5c, 0x6e, 0x20, 0x64, 0x69, 0x76, 0x2e, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x28, 0x29, 0x3b, 0x5c, 0x6e, 0x7d, 0x2c, 0x20, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x2b, 0x20, 0x31, 0x30, 0x30, 0x30, 0x29, 0x3b, 0x60, 0x29, 0x7d, 0x3b, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x2e, 0x77, 0x65, 0x62, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x64, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x72, 0x2e, 0x61, 0x74, 0x74, 0x61, 0x63, 0x68, 0x28, 0x22, 0x31, 0x2e, 0x33, 0x22, 0x29, 0x3b, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x2e, 0x77, 0x65, 0x62, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x64, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x72, 0x2e, 0x73, 0x65, 0x6e, 0x64, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x28, 0x22, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x22, 0x29, 0x3b, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x2e, 0x77, 0x65, 0x62, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x64, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x72, 0x2e, 0x73, 0x65, 0x6e, 0x64, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x28, 0x22, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x73, 0x65, 0x74, 0x42, 0x79, 0x70, 0x61, 0x73, 0x73, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x57, 0x6f, 0x72, 0x6b, 0x65, 0x72, 0x22, 0x2c, 0x7b, 0x62, 0x79, 0x70, 0x61, 0x73, 0x73, 0x3a, 0x74, 0x72, 0x75, 0x65, 0x7d, 0x29, 0x3b, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x2e, 0x77, 0x65, 0x62, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x64, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x72, 0x2e, 0x73, 0x65, 0x6e, 0x64, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x28, 0x22, 0x46, 0x65, 0x74, 0x63, 0x68, 0x2e, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x22, 0x2c, 0x7b, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x73, 0x3a, 0x5b, 0x7b, 0x75, 0x72, 0x6c, 0x50, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x3a, 0x22, 0x2a, 0x3a, 0x2f, 0x2f, 0x61, 0x70, 0x70, 0x2e, 0x68, 0x74, 0x74, 0x70, 0x74, 0x6f, 0x6f, 0x6c, 0x6b, 0x69, 0x74, 0x2e, 0x74, 0x65, 0x63, 0x68, 0x2f, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x6a, 0x73, 0x2a, 0x22, 0x2c, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x22, 0x53, 0x63, 0x72, 0x69, 0x70, 0x74, 0x22, 0x2c, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x53, 0x74, 0x61, 0x67, 0x65, 0x3a, 0x22, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x7d, 0x5d, 0x7d, 0x29, 0x3b, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x2e, 0x77, 0x65, 0x62, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x64, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x72, 0x2e, 0x6f, 0x6e, 0x28, 0x22, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x2c, 0x28, 0x28, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2c, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x2c, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x29, 0x3d, 0x3e, 0x7b, 0x69, 0x66, 0x28, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x21, 0x3d, 0x3d, 0x22, 0x46, 0x65, 0x74, 0x63, 0x68, 0x2e, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x61, 0x75, 0x73, 0x65, 0x64, 0x22, 0x29, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x3b, 0x69, 0x66, 0x28, 0x21, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x2e, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x43, 0x6f, 0x64, 0x65, 0x29, 0x7b, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x2e, 0x77, 0x65, 0x62, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x64, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x72, 0x2e, 0x73, 0x65, 0x6e, 0x64, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x28, 0x22, 0x46, 0x65, 0x74, 0x63, 0x68, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x69, 0x6e, 0x75, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x2c, 0x7b, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x49, 0x64, 0x3a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x2e, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x49, 0x64, 0x7d, 0x29, 0x3b, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x7d, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x49, 0x64, 0x3d, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x2e, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x49, 0x64, 0x3b, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x2e, 0x77, 0x65, 0x62, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x64, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x72, 0x2e, 0x73, 0x65, 0x6e, 0x64, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x28, 0x22, 0x46, 0x65, 0x74, 0x63, 0x68, 0x2e, 0x67, 0x65, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x6f, 0x64, 0x79, 0x22, 0x2c, 0x7b, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x49, 0x64, 0x3a, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x49, 0x64, 0x7d, 0x29, 0x2e, 0x74, 0x68, 0x65, 0x6e, 0x28, 0x28, 0x28, 0x7b, 0x62, 0x6f, 0x64, 0x79, 0x3a, 0x62, 0x6f, 0x64, 0x79, 0x2c, 0x62, 0x61, 0x73, 0x65, 0x36, 0x34, 0x45, 0x6e, 0x63, 0x6f, 0x64, 0x65, 0x64, 0x3a, 0x62, 0x61, 0x73, 0x65, 0x36, 0x34, 0x45, 0x6e, 0x63, 0x6f, 0x64, 0x65, 0x64, 0x7d, 0x29, 0x3d, 0x3e, 0x7b, 0x6c, 0x65, 0x74, 0x20, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x3d, 0x62, 0x61, 0x73, 0x65, 0x36, 0x34, 0x45, 0x6e, 0x63, 0x6f, 0x64, 0x65, 0x64, 0x3f, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2e, 0x66, 0x72, 0x6f, 0x6d, 0x28, 0x62, 0x6f, 0x64, 0x79, 0x2c, 0x22, 0x62, 0x61, 0x73, 0x65, 0x36, 0x34, 0x22, 0x29, 0x2e, 0x74, 0x6f, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x28, 0x22, 0x75, 0x74, 0x66, 0x38, 0x22, 0x29, 0x3a, 0x62, 0x6f, 0x64, 0x79, 0x3b, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x3d, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x72, 0x65, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x28, 0x2f, 0x79, 0x69, 0x65, 0x6c, 0x64, 0x5c, 0x28, 0x30, 0x2c, 0x2e, 0x2a, 0x3f, 0x5c, 0x2e, 0x67, 0x65, 0x74, 0x4c, 0x61, 0x74, 0x65, 0x73, 0x74, 0x55, 0x73, 0x65, 0x72, 0x44, 0x61, 0x74, 0x61, 0x5c, 0x29, 0x5c, 0x28, 0x5c, 0x29, 0x2f, 0x2c, 0x27, 0x7b, 0x22, 0x75, 0x73, 0x65, 0x72, 0x49, 0x64, 0x22, 0x3a, 0x22, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x7c, 0x30, 0x22, 0x2c, 0x22, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x22, 0x3a, 0x22, 0x70, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0x40, 0x68, 0x74, 0x74, 0x70, 0x74, 0x6f, 0x6f, 0x6c, 0x6b, 0x69, 0x74, 0x2e, 0x74, 0x65, 0x63, 0x68, 0x22, 0x2c, 0x22, 0x73, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x3a, 0x7b, 0x22, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0x3a, 0x22, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x22, 0x2c, 0x22, 0x70, 0x6c, 0x61, 0x6e, 0x22, 0x3a, 0x22, 0x70, 0x72, 0x6f, 0x2d, 0x70, 0x65, 0x72, 0x70, 0x65, 0x74, 0x75, 0x61, 0x6c, 0x22, 0x2c, 0x22, 0x73, 0x6b, 0x75, 0x22, 0x3a, 0x22, 0x70, 0x72, 0x6f, 0x2d, 0x70, 0x65, 0x72, 0x70, 0x65, 0x74, 0x75, 0x61, 0x6c, 0x22, 0x2c, 0x22, 0x74, 0x69, 0x65, 0x72, 0x43, 0x6f, 0x64, 0x65, 0x22, 0x3a, 0x22, 0x70, 0x72, 0x6f, 0x22, 0x2c, 0x22, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x22, 0x3a, 0x22, 0x70, 0x65, 0x72, 0x70, 0x65, 0x74, 0x75, 0x61, 0x6c, 0x22, 0x2c, 0x22, 0x71, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x22, 0x3a, 0x31, 0x2c, 0x22, 0x65, 0x78, 0x70, 0x69, 0x72, 0x79, 0x22, 0x3a, 0x6e, 0x65, 0x77, 0x20, 0x44, 0x61, 0x74, 0x65, 0x28, 0x22, 0x39, 0x39, 0x39, 0x39, 0x2d, 0x30, 0x31, 0x2d, 0x30, 0x31, 0x54, 0x30, 0x30, 0x3a, 0x30, 0x30, 0x3a, 0x30, 0x30, 0x2e, 0x30, 0x30, 0x30, 0x5a, 0x22, 0x29, 0x2c, 0x22, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x42, 0x69, 0x6c, 0x6c, 0x69, 0x6e, 0x67, 0x44, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x55, 0x72, 0x6c, 0x22, 0x3a, 0x22, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x37, 0x69, 0x37, 0x75, 0x35, 0x2f, 0x68, 0x74, 0x74, 0x70, 0x2d, 0x74, 0x6f, 0x6f, 0x6c, 0x6b, 0x69, 0x74, 0x2d, 0x70, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x22, 0x2c, 0x22, 0x63, 0x61, 0x6e, 0x63, 0x65, 0x6c, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x55, 0x72, 0x6c, 0x22, 0x3a, 0x22, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x37, 0x69, 0x37, 0x75, 0x35, 0x2f, 0x68, 0x74, 0x74, 0x70, 0x2d, 0x74, 0x6f, 0x6f, 0x6c, 0x6b, 0x69, 0x74, 0x2d, 0x70, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x22, 0x2c, 0x22, 0x6c, 0x61, 0x73, 0x74, 0x52, 0x65, 0x63, 0x65, 0x69, 0x70, 0x74, 0x55, 0x72, 0x6c, 0x22, 0x3a, 0x22, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x37, 0x69, 0x37, 0x75, 0x35, 0x2f, 0x68, 0x74, 0x74, 0x70, 0x2d, 0x74, 0x6f, 0x6f, 0x6c, 0x6b, 0x69, 0x74, 0x2d, 0x70, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x22, 0x2c, 0x22, 0x63, 0x61, 0x6e, 0x4d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x3a, 0x74, 0x72, 0x75, 0x65, 0x7d, 0x2c, 0x22, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x46, 0x6c, 0x61, 0x67, 0x73, 0x22, 0x3a, 0x5b, 0x5d, 0x2c, 0x22, 0x62, 0x61, 0x6e, 0x6e, 0x65, 0x64, 0x22, 0x3a, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x7d, 0x27, 0x29, 0x3b, 0x70, 0x61, 0x74, 0x63, 0x68, 0x5f, 0x61, 0x6c, 0x65, 0x72, 0x74, 0x28, 0x22, 0x50, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0x20, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x6a, 0x73, 0x22, 0x29, 0x3b, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x2e, 0x77, 0x65, 0x62, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x64, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x72, 0x2e, 0x73, 0x65, 0x6e, 0x64, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x28, 0x22, 0x46, 0x65, 0x74, 0x63, 0x68, 0x2e, 0x66, 0x75, 0x6c, 0x66, 0x69, 0x6c, 0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x2c, 0x7b, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x49, 0x64, 0x3a, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x49, 0x64, 0x2c, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x43, 0x6f, 0x64, 0x65, 0x3a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x2e, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x43, 0x6f, 0x64, 0x65, 0x2c, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73, 0x3a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x2e, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73, 0x2c, 0x62, 0x6f, 0x64, 0x79, 0x3a, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2e, 0x66, 0x72, 0x6f, 0x6d, 0x28, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x29, 0x2e, 0x74, 0x6f, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x28, 0x22, 0x62, 0x61, 0x73, 0x65, 0x36, 0x34, 0x22, 0x29, 0x7d, 0x29, 0x7d, 0x29, 0x29, 0x2e, 0x63, 0x61, 0x74, 0x63, 0x68, 0x28, 0x28, 0x65, 0x72, 0x72, 0x3d, 0x3e, 0x7b, 0x70, 0x61, 0x74, 0x63, 0x68, 0x5f, 0x61, 0x6c, 0x65, 0x72, 0x74, 0x28, 0x22, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x70, 0x61, 0x74, 0x63, 0x68, 0x20, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x6a, 0x73, 0x22, 0x29, 0x3b, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x2e, 0x77, 0x65, 0x62, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x64, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x72, 0x2e, 0x73, 0x65, 0x6e, 0x64, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x28, 0x22, 0x46, 0x65, 0x74, 0x63, 0x68, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x69, 0x6e, 0x75, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x2c, 0x7b, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x49, 0x64, 0x3a, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x49, 0x64, 0x7d, 0x29, 0x7d, 0x29, 0x29, 0x7d, 0x29, 0x29, 0x3b, 0x0d, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66, 0x20, 0x28, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x41, 0x75, 0x74, 0x6f, 0x48, 0x69, 0x64, 0x65, 0x4d, 0x65, 0x6e, 0x75, 0x28, 0x29, 0x29, 0x20, 0x7b
				]
			}
		]);

		return m;
	})
}

fn get_os_name() -> &'static str {
	if cfg!(windows) {
		"windows"
	} else if cfg!(target_os = "macos") {
		"macos"
	} else if cfg!(unix) {
		"unix"
	} else {
		"unknown"
	}
}

fn replace_bytes(data: &[u8], target: &[u8], replacement: &[u8]) -> Vec<u8> {
	let mut result = Vec::new();
	let mut i = 0;
	let mut count = 0;

	log(&format!("Starting search for byte sequence (len: {})", target.len()), LogLevel::Info);

	while i < data.len() {
		if i + target.len() <= data.len() && &data[i..i + target.len()] == target {
			log(&format!("Match found at offset 0x{:X}", i), LogLevel::Success);

			result.extend_from_slice(replacement);
			i += target.len();
			count += 1;
		} else {
			result.push(data[i]);
			i += 1;
		}
	}

	if count > 0 {
		log(&format!("Replacement complete. Total replacements: {}", count), LogLevel::Success);
	} else {
		log("No matches found in the file.", LogLevel::Warning);
	}

	result
}

fn get_os_paths() -> Option<PatchPaths> {
	let patch_paths = init_patch_paths();
	let paths = patch_paths.get(get_os_name())?;
	return Some(paths.clone());
}

fn get_asar_integrity_hash(path: &Path) -> Result<String, String> {
	let bytes = fs::read(path).map_err(|e| format!("Failed to read ASAR file ({})", e.to_string()))?;
	let header_size_bytes = &bytes[12..16].try_into().map_err(|e: std::array::TryFromSliceError| format!("Failed to convert header size bytes ({})", e.to_string()))?;
	let header_size = u32::from_le_bytes(*header_size_bytes) as usize;
	let header_bytes = &bytes[16..16 + header_size];
	let mut hasher = Sha256::new();
	hasher.update(header_bytes);
	let result = hasher.finalize();
	return Ok(format!("{:x}", result));
}

fn get_unpacked_files<P: AsRef<Path>>(asar_path: P) -> Vec<String> {
	if let Some(parent_dir) = asar_path.as_ref().parent() {
		let unpacked_folder = parent_dir.join("app.asar.unpacked");

		if !unpacked_folder.exists() {
			return Vec::new();
		}

		return WalkDir::new(&unpacked_folder)
			.into_iter()
			.filter_map(|e| e.ok())
			.filter(|e| e.file_type().is_file())
			.filter_map(|e| {
				// Strip the prefix to get the relative path
				e.path()
					.strip_prefix(&unpacked_folder)
					.ok()
					.map(|rel| rel.to_string_lossy().into_owned())
			})
			.collect()
	}
	return Vec::new()
}

fn recreate_unpacked_files<P: AsRef<Path>>(asar_writer: &mut AsarWriter, asar_path: P) -> Result<(), String> {
	if let Some(parent_dir) = asar_path.as_ref().parent() {
		let unpacked_folder = parent_dir.join("app.asar.unpacked");
		if !unpacked_folder.exists() {
			return Ok(())
		}
		let unpacked_files = get_unpacked_files(&asar_path);
		for rel_path in unpacked_files.iter() {
			let path = unpacked_folder.join(rel_path);
			let bytes = fs::read(&path).map_err(|e| format!("Failed to read file ({})", e.to_string()))?;
			asar_writer.write_file(&rel_path, bytes, false).map_err(|e| format!("Failed to write file ({})", e.to_string()))?;
		}
	}

	return Ok(());
}

fn apply_patches(patched_asar: & mut AsarWriter, asar: &AsarReader) -> Result<(), String> {
	let patches = init_patches();
	for (path_string, patch_list) in patches.iter() {
		let path = Path::new(path_string);
		if let Some(file) = asar.files().get(path) {
			let mut bytes = file.data().to_vec();
			for patch in patch_list {
				if bytes.windows(patch.replacement.len()).any(|w| w == patch.replacement) {
					return Err("The asar has already been patched".into());
				}
				let patched_bytes = replace_bytes(&bytes, &patch.original, &patch.replacement);
				if patched_bytes != bytes {
					bytes = patched_bytes;
				} else {
					return Err("Failed to apply patches (This may mean it has already been patched)".into());
				}
			};
			patched_asar.write_file(path, bytes, false).map_err(|e| format!("Failed to write the patched file: {} ({})", path_string, e.to_string()))?;
		}
	}
	return Ok(())
}

fn patch_asar_file<P: AsRef<Path>>(asar_path: P) -> Result<(), String> {
	log("Starting patch", LogLevel::Info);
	log("Reading asar file", LogLevel::Info);
	let asar_file = fs::read(asar_path.as_ref()).map_err(|e| format!("Failed to read ASAR file ({})", e))?;
	let asar = AsarReader::new(&asar_file, None).map_err(|e| format!("Failed to parse ASAR file ({})", e))?;

	let mut patched_asar = AsarWriter::new();
	log("Recreating files. Please wait...", LogLevel::Info);

	// Add unpacked and patches to the writer.
	recreate_unpacked_files(&mut patched_asar, asar_path.as_ref()).map_err(|e| format!("Failed to recreate unpacked files ({})", e))?;
	apply_patches(&mut patched_asar, &asar)?;

	for (path, file) in asar.files() {
		let path_string = path.to_string_lossy();
		let success = patched_asar.write_file(path, file.data(), false);
		if success.is_err() { // This will error if the file has already been written (patched/unpacked files). This is fine. (it might be quicker to check if we have already written the file but idk)
			log(&format!("Failed to write file: {} (probably patched or unpacked)", path_string.as_ref()), LogLevel::Warning);
		}
	}

	log("Files recreated!", LogLevel::Success);

	let mut backup_path = asar_path.as_ref().to_path_buf();
	backup_path.set_file_name("app.asar.backup");
	log(&format!("Backing up app.asar to {}", backup_path.display()), LogLevel::Info);

	fs::rename(asar_path.as_ref(), backup_path).map_err(|e| format!("Failed to backup app.asar ({})", e.to_string()))?;

	log("Writing patched ASAR", LogLevel::Info);

	let patched_writer = fs::File::create(asar_path.as_ref()).map_err(|e| format!("Failed to create patched ASAR file ({})", e.to_string()))?;
	patched_asar.finalize(patched_writer).map_err(|e| format!("Failed to finalize patched ASAR ({})", e.to_string()))?;

	log("ASAR patched successfully", LogLevel::Success);

	return Ok(())
}

fn patch_binary_file<P: AsRef<Path>>(base_path: P) -> Result<(), String> {
	log("Patching binary file", LogLevel::Info);
	let patch_paths = get_os_paths().unwrap();

	if cfg!(unix) { // Electron doesnt support integrity checking on linux
		log("Binary patching not required on this platform", LogLevel::Info);
		return Ok(())
	}

	let asar_path = base_path.as_ref().join(patch_paths.asar_path);
	let binary_path = base_path.as_ref().join(patch_paths.binary_path);
	let asar_backup_path = asar_path.with_extension("asar.backup");

	let original_hash = get_asar_integrity_hash(asar_backup_path.as_ref())?;
	let replacement_hash = get_asar_integrity_hash(asar_path.as_ref())?;
	log("ASAR integrity hashes calculated successfully", LogLevel::Success);

	let binary_data = fs::read(&binary_path).map_err(|e| format!("Failed to open binary file ({})", e.to_string()))?;

	let patched_data = replace_bytes(
		&binary_data,
		original_hash.as_bytes(),
		replacement_hash.as_bytes()
	);

	let binary_backup_path = binary_path.with_extension("binary.backup");
	log("Creating backup file", LogLevel::Info);
	fs::rename(&binary_path, &binary_backup_path).map_err(|e| format!("Failed to create backup file ({})", e.to_string()))?;
	log("Backup file created successfully", LogLevel::Success);

	fs::write(binary_path, patched_data).map_err(|e| format!("Failed to write patched binary file ({})", e.to_string()))?;

	log("Binary patched successfully", LogLevel::Success);

	return Ok(())
}


fn is_valid_base_path<P: AsRef<Path>>(base_path: P) -> bool {
	let os_paths = get_os_paths();
	if let Some(os_paths) = os_paths {

		let asar_path = base_path.as_ref().join(os_paths.asar_path);
		let binary_path = base_path.as_ref().join(os_paths.binary_path);
		if asar_path.exists() && binary_path.exists() {
			return true;
		}
	}
	return false;
}

fn detect_base_path() -> Option<PathBuf> {
	let os_paths = get_os_paths();
	if let Some(os_paths) = os_paths {
		for path in os_paths.base_paths.iter() {
			if is_valid_base_path(path) {
				return Some(PathBuf::from(path));
			}
		}
	}
	return None;
}

mod logger;
use logger::{log, LogLevel};

#[cfg(windows)]
#[link(name = "shell32")]
unsafe extern "system" {
	fn IsUserAnAdmin() -> bool;
}

#[cfg(windows)]
pub fn is_admin() -> bool {
	unsafe { IsUserAnAdmin() }
}

#[cfg(unix)]
pub fn is_admin() -> bool {
	use libc::{geteuid, getuid};
	unsafe { getuid() == 0 || geteuid() == 0 }
}

fn main() {
	let is_admin = is_admin();
	if !is_admin {
		log("You must run this program as an administrator.", LogLevel::Error);
		return;
	}

	let args: Vec<String> = env::args().collect();

	let base_path_opt = args.get(1)
		.map(PathBuf::from)
		.or(detect_base_path());

	let base_path = match base_path_opt {
		Some(path) => path,
		None => {
			log("Could not detect base path. Please run the command again with the base path as an argument.", LogLevel::Error);
			return;
		}
	};

	if !is_valid_base_path(&base_path) {
		log(&format!("The path {} is not a valid installation path.", base_path.display()), LogLevel::Error);
		return;
	}

	log(&format!("Using path: {}", base_path.display()), LogLevel::Success);
	let asar_path = base_path.join(get_os_paths().unwrap().asar_path);

	let result = patch_asar_file(asar_path);
	if result.is_err() {
		log(&format!("Failed to patch asar file. {}", result.err().unwrap()), LogLevel::Error);
		return;
	}

	let result = patch_binary_file(base_path);
	if result.is_err() {
		log(&format!("Failed to patch binary file. {}", result.err().unwrap()), LogLevel::Error);
		return;
	}

}
