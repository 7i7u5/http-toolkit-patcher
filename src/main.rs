// Prevent console window in addition to Slint window in Windows release builds when, e.g., starting the app via file manager. Ignored on other platforms.
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]
//TODO: auto detect version and see if we can patch...
use std::time;
use std::{error::Error, fs};
use std::collections::HashMap;
use std::sync::{OnceLock};
use std::path::{ Path, PathBuf };
use native_dialog::{ DialogBuilder, MessageLevel };
use asar::{ AsarReader, AsarWriter };
use walkdir::WalkDir;
use sha2::{Sha256, Digest};
use std::thread;
use std::io::Write;
#[cfg(windows)]
use std::os::windows::process::CommandExt;
use std::process::{Command, Child, Stdio, ChildStdin};

slint::include_modules!();

struct Patch {
	original: Vec<u8>,
	replacement: Vec<u8>,
}

#[derive(Clone)]
struct PatchPaths {
	base_paths: Vec<String>,
	binary_path: &'static str,
	asar_path: &'static str
}

struct ElevatedShell {
	stdin: ChildStdin,
	_child: Child,
}

impl ElevatedShell {
	fn new() -> Result<Self, String> {
		let mut child = {
			#[cfg(windows)] {
				Command::new("powershell.exe")
					.creation_flags(0x08000000) // CREATE_NO_WINDOW
					.args(&["-NoExit", "-Command", "-"])
					.stdin(Stdio::piped())
					.stdout(Stdio::inherit())
					.spawn()
					.map_err(|e| e.to_string())?
			}

			#[cfg(unix)] {
				Command::new("sudo")
					.arg("-s")
					.stdin(Stdio::piped())
					.stdout(Stdio::inherit())
					.stderr(Stdio::inherit())
					.spawn()
					.map_err(|e| e.to_string())?
			}
		};
		let stdin = child.stdin.take().ok_or("Failed to open stdin")?;

		Ok(Self {
			stdin,
			_child: child,
		})
	}

	fn run_command(&mut self, cmd: &str) -> Result<(), String> {
		writeln!(self.stdin, "{}", cmd).map_err(|e| e.to_string())?;
		self.stdin.flush().map_err(|e| e.to_string())?;
		Ok(())
	}
}

static PATCHES: OnceLock<HashMap<String, Vec<Patch>>> = OnceLock::new();
static PATCH_PATHS: OnceLock<HashMap<String, PatchPaths>> = OnceLock::new();


#[cfg(windows)]
#[link(name = "shell32")]
unsafe extern "system" {
	fn IsUserAnAdmin() -> bool;
}

fn init_patch_paths() -> &'static HashMap<String, PatchPaths> {
	PATCH_PATHS.get_or_init(|| {
		let mut m = HashMap::new();
		m.insert("windows".to_string(), PatchPaths {
			base_paths: vec![
				"C:/Program Files/HTTP Toolkit".to_string(),
				format!("C:/Users/{}/AppData/Local/Programs/HTTP Toolkit", whoami::username())
			],
			binary_path: "HTTP Toolkit.exe", asar_path: "resources/app.asar"
		});
		// m.insert("windows".to_string(), vec![
		// 	"C:/Program Files/HTTP Toolkit/".to_string(),
		// 	format!("C:/Users/{}/AppData/Local/Programs/HTTP Toolkit/", whoami::username())
		// ]);

		// m.insert("linux".to_string(), vec![
		// 	"/opt/HTTP Toolkit/".to_string(), //TODO: test more linux distros
		// ]);

		// m.insert("macos".to_string(), vec![
		// 	//TODO: Test macos paths.
		// ]);
		// let m = PatchPaths { asar_paths: [], binary_paths: [] }

		return m;
	})
}

fn init_patches() -> &'static HashMap<String, Vec<Patch>> {
	PATCHES.get_or_init(|| {
		let mut m = HashMap::new();
		m.insert("build\\index.js".to_string(), vec![
			Patch {
				original: vec![
					0x20, 0x20, 0x20, 0x20, 0x7d, 0x29, 0x3b, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66, 0x20, 0x28, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x41, 0x75, 0x74, 0x6f, 0x48, 0x69, 0x64, 0x65, 0x4d, 0x65, 0x6e, 0x75, 0x28, 0x29, 0x29, 0x20, 0x7b				],
				replacement: vec![
					0x20, 0x20, 0x20, 0x20, 0x7d, 0x29, 0x3b, 0x0d, 0x0a, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x20, 0x70, 0x61, 0x74, 0x63, 0x68, 0x5f, 0x61, 0x6c, 0x65, 0x72, 0x74, 0x3d, 0x28, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x2c, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x3d, 0x33, 0x65, 0x33, 0x29, 0x3d, 0x3e, 0x7b, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x2e, 0x77, 0x65, 0x62, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x4a, 0x61, 0x76, 0x61, 0x53, 0x63, 0x72, 0x69, 0x70, 0x74, 0x28, 0x60, 0x6c, 0x65, 0x74, 0x20, 0x64, 0x69, 0x76, 0x20, 0x3d, 0x20, 0x64, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x45, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x28, 0x22, 0x64, 0x69, 0x76, 0x22, 0x29, 0x3b, 0x5c, 0x6e, 0x6c, 0x65, 0x74, 0x20, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x3d, 0x20, 0x24, 0x7b, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x7d, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x20, 0x3d, 0x20, 0x22, 0x34, 0x30, 0x70, 0x78, 0x22, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x62, 0x61, 0x63, 0x6b, 0x67, 0x72, 0x6f, 0x75, 0x6e, 0x64, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x20, 0x3d, 0x20, 0x22, 0x72, 0x67, 0x62, 0x28, 0x35, 0x30, 0x2c, 0x20, 0x35, 0x32, 0x2c, 0x20, 0x35, 0x39, 0x29, 0x22, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x3d, 0x20, 0x22, 0x66, 0x69, 0x78, 0x65, 0x64, 0x22, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x62, 0x6f, 0x74, 0x74, 0x6f, 0x6d, 0x20, 0x3d, 0x20, 0x22, 0x2d, 0x35, 0x30, 0x70, 0x78, 0x22, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x3d, 0x20, 0x22, 0x32, 0x30, 0x70, 0x78, 0x22, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x6f, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x20, 0x3d, 0x20, 0x30, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x62, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x52, 0x61, 0x64, 0x69, 0x75, 0x73, 0x20, 0x3d, 0x20, 0x22, 0x35, 0x70, 0x78, 0x22, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x64, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x20, 0x3d, 0x20, 0x22, 0x66, 0x6c, 0x65, 0x78, 0x22, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x61, 0x6c, 0x69, 0x67, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x20, 0x3d, 0x20, 0x22, 0x63, 0x65, 0x6e, 0x74, 0x65, 0x72, 0x22, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x6a, 0x75, 0x73, 0x74, 0x69, 0x66, 0x79, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x20, 0x3d, 0x20, 0x22, 0x63, 0x65, 0x6e, 0x74, 0x65, 0x72, 0x22, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x63, 0x75, 0x72, 0x73, 0x6f, 0x72, 0x20, 0x3d, 0x20, 0x22, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x22, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x70, 0x61, 0x64, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x3d, 0x20, 0x22, 0x30, 0x20, 0x31, 0x35, 0x70, 0x78, 0x22, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x62, 0x6f, 0x78, 0x53, 0x68, 0x61, 0x64, 0x6f, 0x77, 0x20, 0x3d, 0x20, 0x22, 0x32, 0x70, 0x78, 0x20, 0x33, 0x70, 0x78, 0x20, 0x36, 0x70, 0x78, 0x20, 0x72, 0x67, 0x62, 0x61, 0x28, 0x30, 0x2c, 0x20, 0x30, 0x2c, 0x20, 0x30, 0x2c, 0x20, 0x30, 0x2e, 0x35, 0x29, 0x22, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x20, 0x3d, 0x20, 0x22, 0x72, 0x67, 0x62, 0x28, 0x32, 0x31, 0x38, 0x2c, 0x20, 0x32, 0x31, 0x39, 0x2c, 0x20, 0x32, 0x32, 0x33, 0x29, 0x22, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x66, 0x6f, 0x6e, 0x74, 0x46, 0x61, 0x6d, 0x69, 0x6c, 0x79, 0x20, 0x3d, 0x20, 0x27, 0x22, 0x44, 0x4d, 0x20, 0x53, 0x61, 0x6e, 0x73, 0x22, 0x2c, 0x20, 0x41, 0x72, 0x69, 0x61, 0x6c, 0x2c, 0x20, 0x73, 0x61, 0x6e, 0x73, 0x2d, 0x73, 0x65, 0x72, 0x69, 0x66, 0x27, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x66, 0x6f, 0x6e, 0x74, 0x53, 0x69, 0x7a, 0x65, 0x20, 0x3d, 0x20, 0x22, 0x31, 0x37, 0x70, 0x78, 0x22, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x74, 0x65, 0x78, 0x74, 0x44, 0x65, 0x63, 0x6f, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x3d, 0x20, 0x22, 0x6e, 0x6f, 0x6e, 0x65, 0x22, 0x3b, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x3d, 0x20, 0x22, 0x61, 0x6c, 0x6c, 0x20, 0x30, 0x2e, 0x35, 0x73, 0x20, 0x65, 0x61, 0x73, 0x65, 0x22, 0x3b, 0x5c, 0x6e, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x74, 0x65, 0x78, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x20, 0x3d, 0x20, 0x22, 0x24, 0x7b, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x7d, 0x22, 0x3b, 0x5c, 0x6e, 0x5c, 0x6e, 0x64, 0x69, 0x76, 0x2e, 0x6f, 0x6e, 0x63, 0x6c, 0x69, 0x63, 0x6b, 0x20, 0x3d, 0x20, 0x28, 0x29, 0x20, 0x3d, 0x3e, 0x20, 0x7b, 0x5c, 0x6e, 0x20, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x2e, 0x6f, 0x70, 0x65, 0x6e, 0x28, 0x22, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x37, 0x69, 0x37, 0x75, 0x35, 0x2f, 0x68, 0x74, 0x74, 0x70, 0x2d, 0x74, 0x6f, 0x6f, 0x6c, 0x6b, 0x69, 0x74, 0x2d, 0x70, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x22, 0x2c, 0x20, 0x22, 0x5f, 0x62, 0x6c, 0x61, 0x6e, 0x6b, 0x22, 0x29, 0x3b, 0x5c, 0x6e, 0x7d, 0x3b, 0x5c, 0x6e, 0x5c, 0x6e, 0x64, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x62, 0x6f, 0x64, 0x79, 0x2e, 0x61, 0x70, 0x70, 0x65, 0x6e, 0x64, 0x43, 0x68, 0x69, 0x6c, 0x64, 0x28, 0x64, 0x69, 0x76, 0x29, 0x3b, 0x5c, 0x6e, 0x5c, 0x6e, 0x73, 0x65, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x28, 0x28, 0x29, 0x20, 0x3d, 0x3e, 0x20, 0x7b, 0x5c, 0x6e, 0x20, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x62, 0x6f, 0x74, 0x74, 0x6f, 0x6d, 0x20, 0x3d, 0x20, 0x22, 0x31, 0x30, 0x70, 0x78, 0x22, 0x3b, 0x5c, 0x6e, 0x20, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x6f, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x20, 0x3d, 0x20, 0x30, 0x2e, 0x38, 0x3b, 0x5c, 0x6e, 0x7d, 0x2c, 0x20, 0x35, 0x30, 0x29, 0x3b, 0x5c, 0x6e, 0x5c, 0x6e, 0x73, 0x65, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x28, 0x28, 0x29, 0x20, 0x3d, 0x3e, 0x20, 0x7b, 0x5c, 0x6e, 0x20, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x62, 0x6f, 0x74, 0x74, 0x6f, 0x6d, 0x20, 0x3d, 0x20, 0x22, 0x2d, 0x35, 0x30, 0x70, 0x78, 0x22, 0x3b, 0x5c, 0x6e, 0x20, 0x64, 0x69, 0x76, 0x2e, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x2e, 0x6f, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x20, 0x3d, 0x20, 0x30, 0x3b, 0x5c, 0x6e, 0x7d, 0x2c, 0x20, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x2b, 0x20, 0x35, 0x30, 0x30, 0x29, 0x3b, 0x5c, 0x6e, 0x5c, 0x6e, 0x73, 0x65, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x28, 0x28, 0x29, 0x20, 0x3d, 0x3e, 0x20, 0x7b, 0x5c, 0x6e, 0x20, 0x64, 0x69, 0x76, 0x2e, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x28, 0x29, 0x3b, 0x5c, 0x6e, 0x7d, 0x2c, 0x20, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x2b, 0x20, 0x31, 0x30, 0x30, 0x30, 0x29, 0x3b, 0x60, 0x29, 0x7d, 0x3b, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x2e, 0x77, 0x65, 0x62, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x64, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x72, 0x2e, 0x61, 0x74, 0x74, 0x61, 0x63, 0x68, 0x28, 0x22, 0x31, 0x2e, 0x33, 0x22, 0x29, 0x3b, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x2e, 0x77, 0x65, 0x62, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x64, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x72, 0x2e, 0x73, 0x65, 0x6e, 0x64, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x28, 0x22, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x22, 0x29, 0x3b, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x2e, 0x77, 0x65, 0x62, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x64, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x72, 0x2e, 0x73, 0x65, 0x6e, 0x64, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x28, 0x22, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x73, 0x65, 0x74, 0x42, 0x79, 0x70, 0x61, 0x73, 0x73, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x57, 0x6f, 0x72, 0x6b, 0x65, 0x72, 0x22, 0x2c, 0x7b, 0x62, 0x79, 0x70, 0x61, 0x73, 0x73, 0x3a, 0x74, 0x72, 0x75, 0x65, 0x7d, 0x29, 0x3b, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x2e, 0x77, 0x65, 0x62, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x64, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x72, 0x2e, 0x73, 0x65, 0x6e, 0x64, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x28, 0x22, 0x46, 0x65, 0x74, 0x63, 0x68, 0x2e, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x22, 0x2c, 0x7b, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x73, 0x3a, 0x5b, 0x7b, 0x75, 0x72, 0x6c, 0x50, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x3a, 0x22, 0x2a, 0x3a, 0x2f, 0x2f, 0x61, 0x70, 0x70, 0x2e, 0x68, 0x74, 0x74, 0x70, 0x74, 0x6f, 0x6f, 0x6c, 0x6b, 0x69, 0x74, 0x2e, 0x74, 0x65, 0x63, 0x68, 0x2f, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x6a, 0x73, 0x2a, 0x22, 0x2c, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x22, 0x53, 0x63, 0x72, 0x69, 0x70, 0x74, 0x22, 0x2c, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x53, 0x74, 0x61, 0x67, 0x65, 0x3a, 0x22, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x7d, 0x5d, 0x7d, 0x29, 0x3b, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x2e, 0x77, 0x65, 0x62, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x64, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x72, 0x2e, 0x6f, 0x6e, 0x28, 0x22, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x2c, 0x28, 0x28, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2c, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x2c, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x29, 0x3d, 0x3e, 0x7b, 0x69, 0x66, 0x28, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x21, 0x3d, 0x3d, 0x22, 0x46, 0x65, 0x74, 0x63, 0x68, 0x2e, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x61, 0x75, 0x73, 0x65, 0x64, 0x22, 0x29, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x3b, 0x69, 0x66, 0x28, 0x21, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x2e, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x43, 0x6f, 0x64, 0x65, 0x29, 0x7b, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x2e, 0x77, 0x65, 0x62, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x64, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x72, 0x2e, 0x73, 0x65, 0x6e, 0x64, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x28, 0x22, 0x46, 0x65, 0x74, 0x63, 0x68, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x69, 0x6e, 0x75, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x2c, 0x7b, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x49, 0x64, 0x3a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x2e, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x49, 0x64, 0x7d, 0x29, 0x3b, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x7d, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x49, 0x64, 0x3d, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x2e, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x49, 0x64, 0x3b, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x2e, 0x77, 0x65, 0x62, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x64, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x72, 0x2e, 0x73, 0x65, 0x6e, 0x64, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x28, 0x22, 0x46, 0x65, 0x74, 0x63, 0x68, 0x2e, 0x67, 0x65, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x6f, 0x64, 0x79, 0x22, 0x2c, 0x7b, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x49, 0x64, 0x3a, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x49, 0x64, 0x7d, 0x29, 0x2e, 0x74, 0x68, 0x65, 0x6e, 0x28, 0x28, 0x28, 0x7b, 0x62, 0x6f, 0x64, 0x79, 0x3a, 0x62, 0x6f, 0x64, 0x79, 0x2c, 0x62, 0x61, 0x73, 0x65, 0x36, 0x34, 0x45, 0x6e, 0x63, 0x6f, 0x64, 0x65, 0x64, 0x3a, 0x62, 0x61, 0x73, 0x65, 0x36, 0x34, 0x45, 0x6e, 0x63, 0x6f, 0x64, 0x65, 0x64, 0x7d, 0x29, 0x3d, 0x3e, 0x7b, 0x6c, 0x65, 0x74, 0x20, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x3d, 0x62, 0x61, 0x73, 0x65, 0x36, 0x34, 0x45, 0x6e, 0x63, 0x6f, 0x64, 0x65, 0x64, 0x3f, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2e, 0x66, 0x72, 0x6f, 0x6d, 0x28, 0x62, 0x6f, 0x64, 0x79, 0x2c, 0x22, 0x62, 0x61, 0x73, 0x65, 0x36, 0x34, 0x22, 0x29, 0x2e, 0x74, 0x6f, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x28, 0x22, 0x75, 0x74, 0x66, 0x38, 0x22, 0x29, 0x3a, 0x62, 0x6f, 0x64, 0x79, 0x3b, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x3d, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x72, 0x65, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x28, 0x2f, 0x79, 0x69, 0x65, 0x6c, 0x64, 0x5c, 0x28, 0x30, 0x2c, 0x2e, 0x2a, 0x3f, 0x5c, 0x2e, 0x67, 0x65, 0x74, 0x4c, 0x61, 0x74, 0x65, 0x73, 0x74, 0x55, 0x73, 0x65, 0x72, 0x44, 0x61, 0x74, 0x61, 0x5c, 0x29, 0x5c, 0x28, 0x5c, 0x29, 0x2f, 0x2c, 0x27, 0x7b, 0x22, 0x75, 0x73, 0x65, 0x72, 0x49, 0x64, 0x22, 0x3a, 0x22, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x7c, 0x30, 0x22, 0x2c, 0x22, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x22, 0x3a, 0x22, 0x70, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0x40, 0x68, 0x74, 0x74, 0x70, 0x74, 0x6f, 0x6f, 0x6c, 0x6b, 0x69, 0x74, 0x2e, 0x74, 0x65, 0x63, 0x68, 0x22, 0x2c, 0x22, 0x73, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x3a, 0x7b, 0x22, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0x3a, 0x22, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x22, 0x2c, 0x22, 0x70, 0x6c, 0x61, 0x6e, 0x22, 0x3a, 0x22, 0x70, 0x72, 0x6f, 0x2d, 0x70, 0x65, 0x72, 0x70, 0x65, 0x74, 0x75, 0x61, 0x6c, 0x22, 0x2c, 0x22, 0x73, 0x6b, 0x75, 0x22, 0x3a, 0x22, 0x70, 0x72, 0x6f, 0x2d, 0x70, 0x65, 0x72, 0x70, 0x65, 0x74, 0x75, 0x61, 0x6c, 0x22, 0x2c, 0x22, 0x74, 0x69, 0x65, 0x72, 0x43, 0x6f, 0x64, 0x65, 0x22, 0x3a, 0x22, 0x70, 0x72, 0x6f, 0x22, 0x2c, 0x22, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x22, 0x3a, 0x22, 0x70, 0x65, 0x72, 0x70, 0x65, 0x74, 0x75, 0x61, 0x6c, 0x22, 0x2c, 0x22, 0x71, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x22, 0x3a, 0x31, 0x2c, 0x22, 0x65, 0x78, 0x70, 0x69, 0x72, 0x79, 0x22, 0x3a, 0x6e, 0x65, 0x77, 0x20, 0x44, 0x61, 0x74, 0x65, 0x28, 0x22, 0x39, 0x39, 0x39, 0x39, 0x2d, 0x30, 0x31, 0x2d, 0x30, 0x31, 0x54, 0x30, 0x30, 0x3a, 0x30, 0x30, 0x3a, 0x30, 0x30, 0x2e, 0x30, 0x30, 0x30, 0x5a, 0x22, 0x29, 0x2c, 0x22, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x42, 0x69, 0x6c, 0x6c, 0x69, 0x6e, 0x67, 0x44, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x55, 0x72, 0x6c, 0x22, 0x3a, 0x22, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x37, 0x69, 0x37, 0x75, 0x35, 0x2f, 0x68, 0x74, 0x74, 0x70, 0x2d, 0x74, 0x6f, 0x6f, 0x6c, 0x6b, 0x69, 0x74, 0x2d, 0x70, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x22, 0x2c, 0x22, 0x63, 0x61, 0x6e, 0x63, 0x65, 0x6c, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x55, 0x72, 0x6c, 0x22, 0x3a, 0x22, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x37, 0x69, 0x37, 0x75, 0x35, 0x2f, 0x68, 0x74, 0x74, 0x70, 0x2d, 0x74, 0x6f, 0x6f, 0x6c, 0x6b, 0x69, 0x74, 0x2d, 0x70, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x22, 0x2c, 0x22, 0x6c, 0x61, 0x73, 0x74, 0x52, 0x65, 0x63, 0x65, 0x69, 0x70, 0x74, 0x55, 0x72, 0x6c, 0x22, 0x3a, 0x22, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x37, 0x69, 0x37, 0x75, 0x35, 0x2f, 0x68, 0x74, 0x74, 0x70, 0x2d, 0x74, 0x6f, 0x6f, 0x6c, 0x6b, 0x69, 0x74, 0x2d, 0x70, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x22, 0x2c, 0x22, 0x63, 0x61, 0x6e, 0x4d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x3a, 0x74, 0x72, 0x75, 0x65, 0x7d, 0x2c, 0x22, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x46, 0x6c, 0x61, 0x67, 0x73, 0x22, 0x3a, 0x5b, 0x5d, 0x2c, 0x22, 0x62, 0x61, 0x6e, 0x6e, 0x65, 0x64, 0x22, 0x3a, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x7d, 0x27, 0x29, 0x3b, 0x70, 0x61, 0x74, 0x63, 0x68, 0x5f, 0x61, 0x6c, 0x65, 0x72, 0x74, 0x28, 0x22, 0x50, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0x20, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x6a, 0x73, 0x22, 0x29, 0x3b, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x2e, 0x77, 0x65, 0x62, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x64, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x72, 0x2e, 0x73, 0x65, 0x6e, 0x64, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x28, 0x22, 0x46, 0x65, 0x74, 0x63, 0x68, 0x2e, 0x66, 0x75, 0x6c, 0x66, 0x69, 0x6c, 0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x2c, 0x7b, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x49, 0x64, 0x3a, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x49, 0x64, 0x2c, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x43, 0x6f, 0x64, 0x65, 0x3a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x2e, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x43, 0x6f, 0x64, 0x65, 0x2c, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73, 0x3a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x2e, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73, 0x2c, 0x62, 0x6f, 0x64, 0x79, 0x3a, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2e, 0x66, 0x72, 0x6f, 0x6d, 0x28, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x29, 0x2e, 0x74, 0x6f, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x28, 0x22, 0x62, 0x61, 0x73, 0x65, 0x36, 0x34, 0x22, 0x29, 0x7d, 0x29, 0x7d, 0x29, 0x29, 0x2e, 0x63, 0x61, 0x74, 0x63, 0x68, 0x28, 0x28, 0x65, 0x72, 0x72, 0x3d, 0x3e, 0x7b, 0x70, 0x61, 0x74, 0x63, 0x68, 0x5f, 0x61, 0x6c, 0x65, 0x72, 0x74, 0x28, 0x22, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x70, 0x61, 0x74, 0x63, 0x68, 0x20, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x6a, 0x73, 0x22, 0x29, 0x3b, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x2e, 0x77, 0x65, 0x62, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x64, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x72, 0x2e, 0x73, 0x65, 0x6e, 0x64, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x28, 0x22, 0x46, 0x65, 0x74, 0x63, 0x68, 0x2e, 0x63, 0x6f, 0x6e, 0x74, 0x69, 0x6e, 0x75, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x2c, 0x7b, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x49, 0x64, 0x3a, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x49, 0x64, 0x7d, 0x29, 0x7d, 0x29, 0x29, 0x7d, 0x29, 0x29, 0x3b, 0x0d, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66, 0x20, 0x28, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x41, 0x75, 0x74, 0x6f, 0x48, 0x69, 0x64, 0x65, 0x4d, 0x65, 0x6e, 0x75, 0x28, 0x29, 0x29, 0x20, 0x7b
				]
			}
		]);

		return m;
	})
}

fn clear_log(ui_weak: &slint::Weak<AppWindow>) {
	let handle_weak = ui_weak.clone();

	slint::invoke_from_event_loop(move || {
		if let Some(ui) = handle_weak.upgrade() {
			ui.set_log("".into());
		}
	}).unwrap();
}

fn append_log(ui_weak: &slint::Weak<AppWindow>, text: &str) {
	let text = text.to_string();
	let handle_weak = ui_weak.clone();

	slint::invoke_from_event_loop(move || {
		if let Some(ui) = handle_weak.upgrade() {
			let log = ui.get_log();
			let updated = format!("{}\n{}", log, text);
			ui.set_log(updated.into());
		}
	}).unwrap();
}

fn replace_bytes(data: &[u8], target: &[u8], replacement: &[u8]) -> Vec<u8> {
	let mut result = Vec::new();
	let mut i = 0;

	while i < data.len() {
		if i + target.len() <= data.len() && &data[i..i + target.len()] == target {
			result.extend_from_slice(replacement);
			i += target.len();
		} else {
			result.push(data[i]);
			i += 1;
		}
	}
	result
}

fn get_os_patch_paths() -> Option<PatchPaths> {
	let patch_paths = init_patch_paths();
	let paths = patch_paths.get(get_os_name())?;
	return Some(paths.clone());
}

fn kill_httptoolkit(elevated: & mut ElevatedShell) -> Result<(), String> {
	let option = get_base_path();
	let Some(base_path) = option else {
		return Err("Failed to get base path".to_string());
	};

		let asar_path = base_path.join(patch_paths.asar_path);
		let binary_path = base_path.join(patch_paths.binary_path);
		if binary_path.exists() && asar_path.exists() {
			#[cfg(windows)] {
				return elevated.run_command(&format!("taskkill /im \"{0}\"; Start-Sleep -s 3; taskkill /f /im \"{0}\"", patch_paths.binary_path));
			}

			#[cfg(unix)] {
				return elevated.run_command(&format!("taskkill /im \"{0}\"; Start-Sleep -s 3; taskkill /f /im \"{0}\"", patch_paths.binary_path));
			}
		}

	return Err("Unknown".to_string());
}

fn backup_asar(elevated: & mut ElevatedShell) -> Result<(), String> {
	let option = get_base_path();
	let Some(base_path) = option else {
		return Err("Failed to get base path".to_string());
	};

		let asar_path = base_path.join(patch_paths.asar_path);
		let binary_path = base_path.join(patch_paths.binary_path);
		if binary_path.exists() && asar_path.exists() {
			#[cfg(windows)] {
				return elevated.run_command(&format!("ren \"{}\" \"{}\"", asar_path.to_string_lossy(), "app.asar.backup"));
			}

			#[cfg(unix)] {
				return elevated.run_command(&format!("mv \"{}\" \"{}.backup\"", asar_path.to_string_lossy(), asar_path.to_string_lossy()));
			}
		}

	return Err("Unknown".to_string());
}

fn get_asar_integrity_hash(path: &Path) -> Result<String, String> {
	let bytes = fs::read(path).map_err(|e| format!("Failed to read ASAR file ({})", e.to_string()))?;
	let header_size_bytes = &bytes[12..16].try_into().map_err(|e: std::array::TryFromSliceError| format!("Failed to convert header size bytes ({})", e.to_string()))?;
	let header_size = u32::from_le_bytes(*header_size_bytes) as usize;
	let header_bytes = &bytes[16..16 + header_size];
	let mut hasher = Sha256::new();
	hasher.update(header_bytes);
	let result = hasher.finalize();
	let master_hash = format!("{:x}", result);
	return Ok(master_hash);
}

fn get_unpacked_files<P: AsRef<Path>>(asar_path: P) -> Vec<String> {
	if let Some(parent_dir) = asar_path.as_ref().parent() {
		let unpacked_folder = parent_dir.join("app.asar.unpacked");

		if !unpacked_folder.exists() {
			return Vec::new();
		}

		return WalkDir::new(&unpacked_folder)
			.into_iter()
			.filter_map(|e| e.ok())
			.filter(|e| e.file_type().is_file())
			.filter_map(|e| {
				// Strip the prefix to get the relative path
				e.path()
					.strip_prefix(&unpacked_folder)
					.ok()
					.map(|rel| rel.to_string_lossy().into_owned())
			})
			.collect()
	}
	return Vec::new()
}

fn recreate_unpacked_files<P: AsRef<Path>>(asar_writer: &mut AsarWriter, asar_path: P) -> Result<(), String> {
	if let Some(parent_dir) = asar_path.as_ref().parent() {
		let unpacked_folder = parent_dir.join("app.asar.unpacked");
		if !unpacked_folder.exists() {
			return Ok(())
		}
		let unpacked_files = get_unpacked_files(&asar_path);
		for rel_path in unpacked_files.iter() {
			let path = unpacked_folder.join(rel_path);
			let bytes = fs::read(&path).map_err(|e| format!("Failed to read file ({})", e.to_string()))?;
			asar_writer.write_file(&rel_path, bytes, false).map_err(|e| format!("Failed to write file ({})", e.to_string()))?;
		}
	}

	return Ok(());
}

fn apply_patches(patched_asar: & mut AsarWriter, asar: &AsarReader) -> Result<(), String> {
	let patches = init_patches();
	for (path_string, patch_list) in patches.iter() {
		let path = Path::new(path_string);
		if let Some(file) = asar.files().get(path) {
			let mut bytes = file.data().to_vec();
			for patch in patch_list {
				let patched_bytes = replace_bytes(&bytes, &patch.original, &patch.replacement); // Check if actually already patched
				if patched_bytes != bytes {
					bytes = patched_bytes;
				} else {
					return Err("Failed to apply patches (This may mean it has already been patched)".into());
				}
			};
			patched_asar.write_file(path, bytes, false).map_err(|e| format!("Failed to write the patched file: {} ({})", path_string, e.to_string()))?;
		}
	}
	return Ok(())
}

fn patch_asar_file<P: AsRef<Path>>(asar_path: P, ui: &slint::Weak<AppWindow>) -> Result<(), String> {
	clear_log(ui);
	append_log(ui, "Starting patch!");
	append_log(ui, "Reading asar file.");

	let asar_file = fs::read(asar_path.as_ref()).map_err(|e| format!("Failed to read ASAR file ({})", e))?;
	let asar = AsarReader::new(&asar_file, None).map_err(|e| format!("Failed to parse ASAR file ({})", e))?;

	let mut patched_asar = AsarWriter::new();
	append_log(ui, "Recreating files. Please wait...");

	// Add unpacked and patches to the writer.
	recreate_unpacked_files(&mut patched_asar, asar_path.as_ref()).map_err(|e| format!("Failed to recreate unpacked files ({})", e))?;
	apply_patches(&mut patched_asar, &asar)?;

	for (path, file) in asar.files() {
		let path_string = path.to_string_lossy();
		let success = patched_asar.write_file(path, file.data(), false);
		if success.is_err() { // This will error if the file has already been written (patched/unpacked files). This is fine. (it might be quicker to check if we have already written the file but idk)
			append_log(ui, &format!("Failed to write file: {} (probably patched or unpacked)", path_string.as_ref()));
		}
	}
	append_log(ui, "Files recreated!");

	append_log(ui, "Killing HTTP Toolkit, this may take a few seconds...");
	let mut elevated = ElevatedShell::new()?;
	let result = kill_httptoolkit(&mut elevated);
	if result.is_err() {
		append_log(ui, &format!("Failed to kill HTTP Toolkit process: {}", result.err().unwrap()));
	}
	thread::sleep(time::Duration::from_secs(3)); // Wait 3 seconds to allow http toolkit to clean up.

	let result = backup_asar(&mut elevated);
	if result.is_err() {
		append_log(ui, &format!("Failed to backup app.asar: {}", result.err().unwrap()));
	}
	append_log(ui, "Backup created!");
	thread::sleep(time::Duration::from_secs(3)); // Wait 3 seconds to allow rename.

	append_log(ui, "Writing patched ASAR");
	let patched_writer = fs::File::create(asar_path.as_ref()).map_err(|e| format!("Failed to create patched ASAR file ({})", e.to_string()))?;
	patched_asar.finalize(patched_writer).map_err(|e| format!("Failed to finalize patched ASAR ({})", e.to_string()))?;

	// Patch binary file to pass integrity check
	let backup_path = asar_path.as_ref().to_path_buf();
	let original_hash = get_asar_integrity_hash(backup_path.as_ref())?;
	let new_hash = get_asar_integrity_hash(asar_path.as_ref())?; //TODO: Repalce the hash in bin file.
	Ok(())
}


fn get_os_name() -> &'static str {
	if cfg!(windows) {
		"windows"
	} else if cfg!(target_os = "macos") {
		"macos"
	} else if cfg!(unix) {
		"unix"
	} else {
		"unknown"
	}
}

fn alert(message: &str, title: &str) {
	let _ = DialogBuilder::message()
		.set_level(MessageLevel::Error)
		.set_title(title)
		.set_text(message)
		.alert()
		.show();
}

fn get_base_path() -> Option<PathBuf> {
	let patch_paths = init_patch_paths();
	let paths = patch_paths.get(get_os_name())?;
	for base_path in &paths.base_paths {
		let path = Path::new(&base_path);
		if path.exists() {
			let binary_path = path.join(paths.binary_path);
			let asar_path = path.join(paths.asar_path);
			if binary_path.exists() && asar_path.exists() {
				return Some(path.to_path_buf());
			}
		}
	}
	return None;
}

fn get_asar_path() -> Option<PathBuf> {
	let patch_paths = init_patch_paths();
	let paths = patch_paths.get(get_os_name())?;
	let mut asar_path = get_base_path()?;
	asar_path.push(paths.asar_path);
	let path = Path::new(&asar_path);
	if path.exists() {
		return Some(path.to_path_buf());
	}

	return None;
}


fn main() -> Result<(), Box<dyn Error>> {
	let ui = AppWindow::new()?;
	let ui_weak = ui.as_weak();

	#[cfg(windows)] { // If windows then it requires admin when starting
		if unsafe { !IsUserAnAdmin() } {
			append_log(&ui_weak, "This program requires admin privileges to run.");
			ui.set_pach_button_enabled(false);
			ui.set_select_button_enabled(false);
		}
	}
	let path = get_asar_path();
	if let Some(value) = path {
		ui.set_asar_path(value.to_string_lossy().as_ref().into());
	}
	ui.set_patcher_version(env!("CARGO_PKG_VERSION").into());

	let ui_weak_select = ui_weak.clone();
	ui.on_select_asar_path(move || {
		let Some(ui) = ui_weak_select.upgrade() else {
			return;
		};

		let file = rfd::FileDialog::new()
			.add_filter("Asar Files", &["asar"])
			.set_directory("/")
			.pick_file();

		if let Some(path) = file {
			ui.set_asar_path(path.to_string_lossy().to_string().into());
			ui.set_pach_button_enabled(true);
		}
	});

	let ui_weak_patch = ui_weak.clone();
	ui.on_patch_asar_file(move || {
		let Some(ui) = ui_weak_patch.upgrade() else {
			return;
		};
		ui.set_pach_button_enabled(false);
		let path = get_asar_path().unwrap_or(PathBuf::from(ui.get_asar_path().to_string()));
		if path.to_string_lossy() == "Could not detect Asar file" {
			alert("No asar file is set!", "Failed to patch");
			return;
		}

		std::thread::spawn({
			let thread_ui_weak = ui_weak_patch.clone();
			let path = path.clone();
			move || {
				let thread_ui_weak_inner = thread_ui_weak.clone();
				let update_ui = move |message: String| {
					let message_copy = message.clone();
					slint::invoke_from_event_loop(move || {
						if let Some(ui) = thread_ui_weak_inner.upgrade() {
							ui.set_pach_button_enabled(true);
							append_log(&thread_ui_weak_inner, &message_copy);
						}
					}).unwrap();
				};

				match patch_asar_file(&path, &thread_ui_weak) {
					Ok(_) => update_ui("SUCCESS: PATCH COMPLETED!".to_string()),
					Err(err) => update_ui(format!("FAILURE: UNABLE TO PATCH! {}", err)),
				}
			}
		});

	});

	ui.run()?;
	Ok(())
}
